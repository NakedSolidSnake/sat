.TH SAT_WORKER 3 "December 2025" "SAT Library" "SAT Library Manual"
.SH NAME
sat_worker \- thread pool management system for parallel task processing
.SH SYNOPSIS
.nf
.B #include <sat_worker.h>
.PP
.BI "sat_status_t sat_worker_init(sat_worker_t *" object );
.BI "sat_status_t sat_worker_open(sat_worker_t *" object ", const sat_worker_args_t *" args );
.BI "sat_status_t sat_worker_feed(sat_worker_t *" object ", const void *" data );
.BI "sat_status_t sat_worker_close(sat_worker_t *" object );
.PP
Link with \fI\-lsat_worker \-lpthread\fP.
.fi
.SH DESCRIPTION
The
.B sat_worker
module provides a thread pool implementation for efficient parallel processing
of tasks. It manages a pool of worker threads that process tasks from a shared
queue, providing an effective way to distribute workload across multiple CPU cores.
.PP
The worker pool operates using a producer-consumer pattern where:
.IP \(bu 2
The main thread (producer) submits tasks via
.BR sat_worker_feed ()
.IP \(bu 2
Worker threads (consumers) dequeue and process tasks concurrently
.IP \(bu 2
Synchronization is handled automatically using mutexes and condition variables
.PP
This module is ideal for applications that need to:
.IP \(bu 2
Process multiple independent tasks in parallel
.IP \(bu 2
Limit CPU resource usage with a fixed thread pool size
.IP \(bu 2
Improve throughput by overlapping I/O and computation
.IP \(bu 2
Handle bursts of work efficiently with a task queue
.SS Types
.TP
.B sat_worker_handler_t
Function pointer type for task processing callbacks:
.RS
.PP
.BI "typedef void (*sat_worker_handler_t)(void *" object );
.PP
The handler function is called by worker threads to process each task. It receives
a pointer to the task data and should perform all necessary processing. The function
must be thread-safe as it will be called concurrently by multiple worker threads.
.RE
.TP
.B sat_worker_t
Structure representing a worker thread pool. Contains:
.RS
.IP \(bu 2
.B mutex
\- Mutex for thread synchronization
.IP \(bu 2
.B cond
\- Condition variable for thread signaling
.IP \(bu 2
.B threads
\- Array of worker thread handles
.IP \(bu 2
.B threads_amount
\- Number of threads in the pool
.IP \(bu 2
.B queue
\- Work queue for task distribution
.IP \(bu 2
.B object_size
\- Size of each task object
.IP \(bu 2
.B handler
\- Task processing callback
.IP \(bu 2
.B running
\- Pool active status flag
.RE
.TP
.B sat_worker_args_t
Configuration structure for worker pool initialization:
.RS
.IP \(bu 2
.B pool_amount
\- Number of worker threads to create (must be > 0)
.IP \(bu 2
.B object_size
\- Size in bytes of each task object (must be > 0)
.IP \(bu 2
.B handler
\- Callback function for processing tasks (must not be NULL)
.RE
.SS Functions
.TP
.BR sat_worker_init ()
Initializes a worker pool structure. Sets up the mutex and condition variable
required for thread synchronization. Must be called before
.BR sat_worker_open ().
.RS
.PP
Returns a status indicating success or failure. Fails if the object pointer is
NULL or if pthread initialization fails.
.RE
.TP
.BR sat_worker_open ()
Opens and starts the worker thread pool. This function:
.RS
.IP 1. 3
Validates the configuration parameters
.IP 2. 3
Creates a work queue with the specified object size
.IP 3. 3
Allocates the specified number of worker threads
.IP 4. 3
Starts all worker threads
.IP 5. 3
Sets the pool to running state
.PP
Worker threads immediately begin waiting for tasks to be submitted. Returns a
status indicating success or failure.
.PP
.B Requirements:
.IP \(bu 2
pool_amount must be greater than 0
.IP \(bu 2
object_size must be greater than 0
.IP \(bu 2
handler must not be NULL
.IP \(bu 2
The handler function must be thread-safe
.RE
.TP
.BR sat_worker_feed ()
Submits a task to the worker pool for processing. The task data is copied into
the work queue, and one of the worker threads will dequeue and process it using
the registered handler function.
.RS
.PP
This function is thread-safe and can be called concurrently from multiple threads.
The operation is protected by the worker pool's mutex.
.PP
If all worker threads are busy, the task waits in the queue until a thread becomes
available. The queue has dynamic sizing based on the
.BR sat_queue (3)
implementation.
.PP
Returns a status indicating success or failure. Fails if the object or data
pointer is NULL, or if the queue is full.
.PP
.B Note:
The task data is copied, so the caller can safely free or reuse the source data
after this function returns.
.RE
.TP
.BR sat_worker_close ()
Shuts down the worker thread pool gracefully. This function:
.RS
.IP 1. 3
Sets the running flag to false
.IP 2. 3
Broadcasts to all worker threads to wake up
.IP 3. 3
Waits for all threads to complete current tasks and exit
.IP 4. 3
Destroys the work queue
.IP 5. 3
Frees thread array memory
.IP 6. 3
Destroys synchronization primitives
.PP
This function blocks until all worker threads have terminated. Any tasks remaining
in the queue when close is called will not be processed.
.PP
Returns a status indicating success or failure. Fails only if the object pointer
is NULL.
.RE
.SH RETURN VALUE
All functions return
.B sat_status_t
indicating success or failure. Use SAT status utility functions to check results.
.SH EXAMPLES
.SS Basic Usage
.nf
#include <sat_worker.h>
#include <stdio.h>

// Task structure
typedef struct {
    int id;
    int value;
} task_t;

// Handler function (must be thread-safe)
void process_task(void *data) {
    task_t *task = (task_t *)data;
    printf("Processing task %d: value=%d\\n", task->id, task->value);
    // Perform task processing...
}

int main(void) {
    sat_worker_t worker;
    
    // Initialize worker pool
    if (!sat_status_is_ok(sat_worker_init(&worker))) {
        fprintf(stderr, "Failed to initialize worker\\n");
        return 1;
    }
    
    // Configure and open worker pool with 4 threads
    sat_worker_args_t args = {
        .pool_amount = 4,
        .object_size = sizeof(task_t),
        .handler = process_task
    };
    
    if (!sat_status_is_ok(sat_worker_open(&worker, &args))) {
        fprintf(stderr, "Failed to open worker\\n");
        return 1;
    }
    
    // Submit tasks
    for (int i = 0; i < 100; i++) {
        task_t task = { .id = i, .value = i * 2 };
        sat_worker_feed(&worker, &task);
    }
    
    // Give workers time to process
    sleep(2);
    
    // Shutdown worker pool
    sat_worker_close(&worker);
    
    return 0;
}
.fi
.SS Producer-Consumer Pattern
.nf
#include <sat_worker.h>
#include <string.h>

typedef struct {
    char filename[256];
    int priority;
} file_task_t;

void process_file(void *data) {
    file_task_t *task = (file_task_t *)data;
    // Process file with given priority
    printf("Processing: %s (priority %d)\\n", 
           task->filename, task->priority);
}

void process_directory(const char *path) {
    sat_worker_t worker;
    sat_worker_init(&worker);
    
    sat_worker_args_t args = {
        .pool_amount = 8,  // 8 worker threads
        .object_size = sizeof(file_task_t),
        .handler = process_file
    };
    sat_worker_open(&worker, &args);
    
    // Submit file processing tasks
    file_task_t task;
    strcpy(task.filename, "document1.pdf");
    task.priority = 1;
    sat_worker_feed(&worker, &task);
    
    strcpy(task.filename, "image.jpg");
    task.priority = 2;
    sat_worker_feed(&worker, &task);
    
    // More tasks...
    
    sat_worker_close(&worker);
}
.fi
.SS Thread-Safe Data Processing
.nf
#include <sat_worker.h>
#include <stdlib.h>

typedef struct {
    double *data;
    size_t size;
    double result;
} compute_task_t;

// Handler must not modify shared state without synchronization
void compute_average(void *data) {
    compute_task_t *task = (compute_task_t *)data;
    double sum = 0.0;
    
    for (size_t i = 0; i < task->size; i++) {
        sum += task->data[i];
    }
    
    task->result = sum / task->size;
}

void parallel_compute(void) {
    sat_worker_t worker;
    sat_worker_init(&worker);
    
    sat_worker_args_t args = {
        .pool_amount = 4,
        .object_size = sizeof(compute_task_t),
        .handler = compute_average
    };
    sat_worker_open(&worker, &args);
    
    // Submit computational tasks
    double data1[] = {1.0, 2.0, 3.0, 4.0};
    compute_task_t task1 = {
        .data = data1,
        .size = 4
    };
    sat_worker_feed(&worker, &task1);
    
    sat_worker_close(&worker);
}
.fi
.SH NOTES
.IP \(bu 2
Worker threads execute concurrently, so the handler function must be thread-safe.
.IP \(bu 2
Tasks are processed in approximately FIFO order, but exact ordering is not guaranteed
due to concurrent execution.
.IP \(bu 2
The optimal number of worker threads depends on the workload characteristics and
available CPU cores. For CPU-bound tasks, use approximately the number of cores.
For I/O-bound tasks, more threads may improve throughput.
.IP \(bu 2
Task data is copied into the queue, adding some overhead. For large tasks, consider
passing pointers to shared data structures (with proper synchronization).
.IP \(bu 2
The work queue uses
.BR sat_queue (3)
internally, which provides dynamic sizing.
.IP \(bu 2
Calling
.BR sat_worker_close ()
while tasks are being processed is safe but will block until
all threads finish their current task.
.IP \(bu 2
Tasks remaining in the queue when
.BR sat_worker_close ()
is called are not processed.
.SH THREAD SAFETY
.TP
.BR sat_worker_feed ()
Thread-safe, can be called from multiple threads simultaneously.
.TP
.BR sat_worker_init (),
.BR sat_worker_open (),
.BR sat_worker_close ()
Not thread-safe, should be called from a single thread during pool lifecycle management.
.TP
Handler function
Must be thread-safe as it executes concurrently in multiple worker threads.
.SH SEE ALSO
.BR sat_status (3),
.BR sat_queue (3),
.BR pthread_create (3),
.BR pthread_mutex_lock (3),
.BR pthread_cond_wait (3)
.SH AUTHOR
SAT Library Team
.SH COPYRIGHT
Copyright \(co 2025 SAT Library Project. Licensed under MIT License.
